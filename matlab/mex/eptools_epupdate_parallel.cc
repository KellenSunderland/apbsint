/* -------------------------------------------------------------------
 * EPTOOLS_EPUPDATE_PARALLEL
 *
 * Local EP updates (in parallel) for all potentials t_j(s_j) of
 * potential manager.
 *
 * Potential manager defined by POTIDS, NUMPOT, PARVEC, PARSHRD. See
 * 'PotManagerFactory' comments for full details.
 * NOTE: This is an internal transfer format, generated by Matlab
 * code.
 * If UPDIND is given, we only update on potentials j in UPDIND. In
 * this case, CMU, CRHO, RSTAT, ALPHA, NU, LOGZ are of the same
 * length as UPDIND.
 *
 * Input:
 * - POTIDS:  Potential manager representation [int32 array]
 * - NUMPOT:  " [int32 array]
 * - PARVEC:  " [double array]
 * - PARSHRD: " [int32 array]
 * - CMU:     Vector cavity means
 * - CRHO:    Vector cavity variances
 * - UPDIND:  S.a. Optional [int32 array]
 *
 * Return:
 * - RSTAT:   Vector of return stati (1: Success, 0: Failure)
 *            [int32 array]
 * - ALPHA:   Vector of alpha values
 * - NU:      Vector of nu values
 * - LOGZ:    Vector of log Z values (optional)
 * -------------------------------------------------------------------
 * Matlab MEX Function
 * Author: Matthias Seeger
 * ------------------------------------------------------------------- */

#include "src/main.h"
#include "matlab/mex/mex_helper.h"
#include "src/eptools/wrap/eptwrap_epupdate_parallel.h"

char errMsg[512];

/* Main function EPTOOLS_EPUPDATE_PARALLEL */

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
  int argidx;
  int* potids,*numpot,*parshrd,*updind=0;
  double* parvec,*cmu,*crho;
  void** annobj;
  int npotids,nnumpot,nparshrd,nupdind=0,nparvec,ncmu,ncrho;
  int* rstat;
  double* alpha,*nu,*logz=0;
  int nrstat,nalpha,nnu,nlogz;
  int errcode;
  char* errstr;

  errstr = errMsg;
  /* Read arguments */
  if (nrhs<6)
    mexErrMsgTxt("Not enough input arguments");
  if (nlhs<3 || nlhs>4)
    mexErrMsgTxt("Wrong number of return arguments");
  argidx = -1; /* ++argidx in macro */
  M_GETIARRAY(potids,"POTIDS");
  M_GETIARRAY(numpot,"NUMPOT");
  M_GETDARRAY(parvec,"PARVEC");
  M_GETIARRAY(parshrd,"PARSHRD");
  M_GETDARRAY(cmu,"CMU");
  M_GETDARRAY(crho,"CRHO");
  if (nrhs>6)
    M_GETIARRAY(updind,"UPDIND");
  /* Create return arguments */
  nrstat = nalpha = nnu = nlogz = ncmu;
  argidx = -1; /* ++argidx in macro */
  M_MAKEIARRAY(rstat);
  M_MAKEDARRAY(alpha);
  M_MAKEDARRAY(nu);
  if (nlhs>3)
    M_MAKEDARRAY(logz);
  /* Call C++ wrapper, deal with error */
  annobj=getZeroVoidArray(npotids); /* Dummy void* array */
  eptwrap_epupdate_parallel(std::min(nrhs+1,8),nlhs,M_ARR(potids),
			    M_ARR(numpot),M_ARR(parvec),M_ARR(parshrd),
			    annobj,npotids,M_ARR(cmu),M_ARR(crho),M_ARR(updind),
			    M_ARR(rstat),M_ARR(alpha),M_ARR(nu),
			    M_ARR(logz),&errcode,errstr);
  mxFree((void*) annobj);
  if (errcode!=0)
    mexErrMsgTxt(errstr);
}
